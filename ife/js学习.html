<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        
    </style>
</head>
<body>
    
<script>
    //字面量构造函数
    //     var per={
    //         name:"xiaoming",
    //         age:18,
    //         salary:20000,
    //         eat:function(){
    //             console.log("爱吃臭豆腐")
    //         },
    //         read:function(){
    //             console.log("坏蛋是怎样炼成的")
    //         }
    //     };
    //     console.log(per instanceof Object)
    // 

    // <!-- 调用系统的构造函数 -->
        // var per = new Object();
        // per.name="xiaoming";
        // per.age=18;
        // per.salary=20000;
        // per.eat = function(){
        //     console.log("爱吃臭豆腐")
        // }
        // per.read = function(){
        //     console.log("坏蛋是怎样炼成的")
        // }
        // function Person(){

        // }
        // console.log(per instanceof Person)

        // 自定义构造函数
            // function Person(name,age,salary){
            //     this.name = name;
            //     this.age = age;
            //     this.salary = salary;
            //     this.eat = function(){
            //         console.log("爱吃臭豆腐")
            //     };
            // }
            // var per = new Person("xiaoming",18,20000);
            // console.log(per instanceof Person)

    // 工厂模式创建对象
    // function createObj(name,age,sex){
    //     var obj = new Object();
    //     obj.name=name;
    //     obj.age = age;
    //     obj.sex = sex;
    //     obj.eat = function(){
    //         console.log("爱吃臭豆腐");
    //     }
    //     return obj;
    // }
    // var per1 = createObj("小明",18,"男");
    // console.log(per1)

    //原型添加方法，解决数据共享，节省内存空间
    // function Person(name,age){
    //     this.name=name;
    //     this.age=age;
    // }
    // Person.prototype.eat = function(){
    //     console.log("臭豆腐")
    // }
    // var per1 = new Person("小明",18);
    // var per2 = new Person("小红",20);
    // console.log(per1);
    // console.log(per2);
    // console.log(per1.eat==per2.eat);
    // console.dir(per1);
    // console.dir(per2);
    // console.dir(Person);

    // 需要共享的数据写在原型中，不需要共享的数据写在构造函数中
    //构造函数
    // function Student(name,age,sex){
    //     this.name=name;
    //     this.age=age;
    //     this.sex=sex;
    // }
    //创建原型对象方法一
    // Student.prototype.weight="55kg";
    // Student.prototype.height="188cm";
    // Student.prototype.study = function(){
    //     console.log("每天至少五百行代码");
    // }
    // Student.prototype.eat = function(){
    //     console.log("我最爱吃榴莲");
    // }
    // 创建原型对象方法二
    // Student.prototype={
    //     //手动修改构造器的指向
    //     constructor:Student,
    //     weight:"55kg",
    //     height:"188cm",
    //     study : function(){
    //         console.log("每天至少五百行代码");
    //     },
    //     eat : function(){
    //         console.log("我最爱吃榴莲");
    //     }
    // };
    //实例化对象
    // var stu = new Student("小明",18,"男");
    // console.dir(Student);
    // console.dir(stu);
    // stu.eat();

    // //原型对象中的属性可以相互访问
    // function Animal(name,age){
    //     this.name=name;
    //     this.age=age;
    // }
    // Animal.prototype.eat = function(){
    //     console.log("动物最爱吃榴莲");
    //     this.sleep();
    // }
    // Animal.prototype.sleep = function(){
    //     console.log("动物睡觉了");
    // }
    // var ani =new Animal("小鸡",5);
    // ani.eat();

    //通过自调用函数产生一个随机数对象,在自调用函数外面,调用该随机数对象方法产生随机数
    // (function(window) {
    //     function Random(){

    //     }
    //     Random.prototype.getRandom = function(min,max){
    //         return Math.floor(Math.random()*(max-min)+min);
    //     }
    //     window.Random =new Random();
    // })(window)
    // var ran = Random;
    // console.log(ran.getRandom(2,5));

    // function Person(age,sex){
    //     this.age=age;
    //     this.sex=sex;
    // }
    // Person.prototype.sex="女";
    // var per=new Person(10,'男');
    // console.log(per.sex);//男
    // console.log(per.hjhjh);//undefined
    // console.log(hjhjh);//报错
    // //因为js是一门动态类型语言，对象没有什么，只要点了，那么对象就有了这个东西，没有这个属性，只要对象.属性名字没对象就有了这个属性，但是该属性没有赋值，所以是undefined

    //实例对象能否改变原型对象的属性值？不能，要改变原型对象的属性值，直接原型对象.属性=值

        // // //人的构造函数
        // function Person(age){
        //     this.age = age;
        // }
        // //人的原型中添加方法
        // Person.prototype.eat = function () {
        //     console.log("人吃");
        // }
        // //学生的构造函数
        // function Student(sex) {
        //     this.sex = sex;
        // }
        // //学生的原型中添加方法
        // Student.prototype.sayHi = function () {
        //     console.log("您好跑");
        // }
        // //改变了原型对象的指向
        // Student.prototype = new Person();
        // var stu=new Student("男");
        // stu.eat();
        // stu.sayHi();//报错,因为改变了指向，原来的student原型相当于没了，解决方法是先改变指向，在添加方法

            // //人的构造函数
            // function Person(age){
            //     this.age = age;
            // }
            // //人的原型中添加方法
            // Person.prototype.eat = function () {
            //     console.log("人吃");
            // }
            // //学生的构造函数
            // function Student(sex) {
            //     this.sex = sex;
            // }
            // //先改变原型对象的指向,相当于原型实现继承
            // Student.prototype = new Person();
            // //学生的原型中添加方法
            // Student.prototype.sayHi = function () {
            //     console.log("您好跑");
            // }
            // // Student.prototype.eat = function () {
            // //     console.log("学生吃");
            // // }
            // var stu=new Student("男");
            // stu.eat();//人吃
            // stu.sayHi();//您好跑
        


        // //利用原型实现继承
        // //动物有名字，有体重，有吃东西的行为
        // //小狗有名字，有体重，有毛色，有吃东西的行为，还有咬人的行为
        // //哈士奇有名字，有体重，有毛色，性别，有吃东西的行为，还有咬人的行为，逗主人开心的行为

        // //动物的构造函数
        // function Animal(name,weight){
        //     this.name=name;
        //     this.weight=weight;
        // }
        // //动物的原型方法
        // Animal.prototype.eat = function () {
        //     console.log("臭豆腐真好次");
        // }

        // //小狗的构造函数
        // function Dog(color){
        //     this.color = color;
        // }
        // //改变小狗原型的指向
        // Dog.prototype = new Animal("哮天犬","50kg");
        // //给小狗添加原型方法
        // Dog.prototype.bitePerson = function () {
        //     console.log("旺旺，咬死你");
        // }

        // //哈士奇的构造函数
        // function Erha(sex){
        //     this.sex = sex;
        // }
        // //改变二哈的原型指向
        // Erha.prototype = new Dog("red");
        // //给erha添加原型方法
        // Erha.prototype.play = function () {
        //     console.log("逗你玩呢");
        // }
        // var erha = new Erha("男的");
        // console.log(erha.color);
        // console.log(erha.sex);
        // erha.bitePerson();
        // erha.play();
        // erha.eat();
        
        // //利用原型实现继承有一个弊端就是初始化了属性，导致其他人没那个属性值也有了
    //     function Person(name,age,sex,weight){
    //         this.name = name;
    //         this.age = age;
    //         this.sex = sex;
    //         this.weight = weight;
    //     }
    //     Person.prototype.sayHi = function () {
    //         console.log("您好哦");
    //     }
    //     function Student(score){
    //         this.score = score;
    //     }
    //     Student.prototype = new Person("小明",18,"男","50kg");
    //     var stu1 = new Student("100");
    //     stu1.sayHi();//您好哦
    //     console.log(stu1.name,stu1.age,stu1.sex,stu1.weight,stu1.score);// 小明 18 男 50kg 100
       
    //     var stu2 = new Student("120");
    //         stu2.name="张三";
    //         stu2.age=20;
    //         stu2.sex="女";
    //     console.log(stu2.name,stu2.age,stu2.sex,stu2.weight,stu2.score);//小明 18 男 50kg 120
    //     stu2.sayHi();//您好哦
    //    stu1.sayHi();//您好哦
        //这样一个个弄太麻烦
        //为了实现数据共享，改变原型指向，做到了继承-----通过改变原型指向实现的继承
        //缺陷：因为改变原型指向的同时实现继承，直接初始化了属性，继承过来的属性的值都是一样的了，所以问题来了
        //只能重新调用对象的属性进行重新赋值
        
        // //解决方案：继承的时候，不用改变原型指向，直接调用父级的构造函数的方式来为属性赋值-----借用构造函数：把要继承的父级的构造函数拿出来，使用一下
        // //借用构造函数：构造函数名字.call(当前对象（通常写this）,属性，属性，属性。。。)；
        // //解决了属性继承，并且值不重复的问题
        // //缺陷：父级类别的方法不能继承
        // function Person(name,age,sex,weight){
        //     this.name = name;
        //     this.age = age;
        //     this.sex = sex;
        //     this.weight = weight;
        // }
        // Person.prototype.width="15px";
        // Person.prototype.sayHi = function () {
        //     console.log("您好哦");
        // }
        // function Student(name,age,sex,weight,score){
        //     this.score = score;
        //     Person.call(this,name,age,sex,weight);
        // }
        // var stu1 = new Student("小红",19,"女","50kg","100")
        // console.log(stu1.width(显示undefined),stu1.name,stu1.age,stu1.sex,stu1.weight,stu1.score);// 小明 18 男 50kg 100
        // stu1.sayHi();//sayHi is not a function报错
        // Student.prototype = new Person("小明",18,"男","50kg","120");
        // console.log(stu2.width(显示undefined),stu2.name,stu2.age,stu2.sex,stu2.weight,stu2.score);//小明 18 男 50kg 120
        // stu2.sayHi();//sayHi is not a function报错
        // stu1.sayHi();//sayHi is not a function报错

            // //原型实现继承
            // //借用构造函数实现继承
            // //组合继承：原型继承+借用构造函数继承
            // function Person(name,age,sex) {
            // this.name=name;
            // this.age=age;
            // this.sex=sex;
            // }
            // Person.prototype.sayHi=function () {
            // console.log("阿涅哈斯诶呦");
            // };
            // function Student(name,age,sex,score) {
            // //借用构造函数:属性值重复的问题
            // Person.call(this,name,age,sex);
            // this.score=score;
            // }
            // //改变原型指向----继承
            // Student.prototype=new Person();//不传值
            // Student.prototype.eat=function () {
            // console.log("吃东西");
            // };
            // var stu=new Student("小黑",20,"男","100分");
            // console.log(stu.name,stu.age,stu.sex,stu.score);
            // stu.sayHi();
            // stu.eat();
            // var stu2=new Student("小黑黑",200,"男人","1010分");
            // console.log(stu2.name,stu2.age,stu2.sex,stu2.score);
            // stu2.sayHi();
            // stu2.eat();
            // //属性和方法都被继承了

            // //拷贝继承：把一个对象中的属性或方法直接复制到另一个对象中
            //     function Person(name){
            //         this.name=name;
            //     }
            //     Person.prototype.age=10;
            //     Person.prototype.sex="男";
            //     Person.prototype.eat = function(){
            //         console.log("吃了");
            //     }
            //     var obj={};
            //     for(var key in Person.prototype){
            //         obj[key] = Person.prototype[key];
            //     }
            //     console.dir(obj);
            //     obj.eat();
        

        // //对象中__proto__原型，是对象
        // //函数中有prototype原型，是对象
        // function F1(){
        // }
        // console.dir(F1);
        // console.dir(Math);
  
            // //数组可以存储任何类型的数据
            // var arr=[
            //     function (){
            //         console.log("1")
            //     },
            //     function (){
            //         console.log("2")
            //     },
            //     function (){
            //         console.log("3")
            //     },
            //     function (){
            //         console.log("4")
            //     }
            // ]
            // //回调函数：函数作为参数使用
            // arr.forEach(function(e){
            //     e();
            // })


</script>

<!-- a.value=2的问题，b继承的是指针，而不是a的值 -->
<!-- 对象复制传递的实际是一个对象的引用（可以理解为指针），所以a和b代表的是一个东西 -->
<!-- <script>
    var a=new Object();
    a.value = 1;
    b = a;
    b.value = 2;
    a.value=3;
    console.log(b.value)
    console.log(a.value)//a=2
</script> -->

<!-- apply和call方法 -->
<!-- apply和call方法改变对象或函数的this指向 
    不同的地方：参数传递方式不一样
    只要是想使用别的对象的方法，并且希望这个方法是当前对象的
那么就可以使用apply/call
-->
<!-- <script>
    function f1(x,y){
        console.log((x+y)+this);
        return "100000";
    }
    f1(10,20);//30,此时this是window
    f1.apply(null);
    f1.call(null);//apply和call方法中没有传入参数，或传入null时，那么调用该方法的this就是window
    f1.apply(null,[100,200])
    f1.call(null,100,200)//300,指向window
</script> -->
<!-- <script>
    function f1(x,y,z){
        console.log("这个函数是window对象的一个方法"+(x+y)+this+this.sex); 
    }
    window.f1(10,20,30);
    //obj是一个对象
    var obj={
        age:10,
        sex:"男"
    };
    window.f1.apply(obj,[10,20,30]);
    window.f1.call(obj,10,20,30);
    console.dir(f1);
</script> -->
<!-- <script>
    function Person(age,sex){
        this.age=age;
        this.sex=sex;
    }
    Person.prototype.say=function(x,y){
        console.log("您好"+this.sex);//您好男
        return 1000;
    }
    var per=new Person(10,"男");
    per.say();

    function Student(name,sex){
        this.name=name;
        this.sex=sex;
    }
    var stu=new Student("小明","人妖");
    var r1=per.say.apply(stu,[10,20]);
    var r2=per.say.call(stu,10,20);
    console.log(r1);
    console.log(r2);//您好人妖

</script> -->


<!-- bind方法 -->
<!-- bind方法是复制的意思，参数可以在复制的时候传入，也可以在复制之后调用的时候传入
    apply和call是调用的时候改变this的指向
    bind方法是复制一份的时候，改变了this的指向
     函数名字.bind(对象,参数1,参数2,...);返回值是复制之后的这个函数
     方法名字.bind(对象,参数1,参数2,...);返回值是复制之后的这个方法
-->
<!-- <script>
    function f1(x,y){
        console.log((x+y)+"==========>"+this)
    }
    var ff=f1.bind(null);
    ff(10,20);
    // 或者
    // var ff=f1.bind(null,10,20)();

    function Person(age){
        this.age=age;
    }
    Person.prototype.play=function(){
        console.log(this+"======>"+this.age);
    };
    function Student(age){
        this.age=age;
    }
    var per=new Person(10);
    var stu=new Student(20);
    per.play()//object,10
    //复制了一份
    var fk=per.play.bind(stu);
    fk();//object,20
    per.play()//object,10
</script> -->
<!-- <script>
    //通过对象，调用方法，产生随机数
    function ShowRandow(){
        this.number=parseInt(Math.random()*10+1);//产生1-10的随机数
    }
    ShowRandow.prototype.show1=function(){
        window.setInterval(
             this.show2.bind(this)
        ,1000);
    }
    ShowRandow.prototype.show2=function(){
        console.log(this.number); 
    }
    var show2=new ShowRandow();
    show2.show1();
</script> -->

<!-- 高阶函数之函数作为参数使用 -->
<!-- <script>
    function f1(fn){
        console.log("f1的函数");
        fn();//此时fn当作是函数使用了
    }
    //传入匿名函数
    f1(function(){
        console.log("我是匿名函数");//此时输出f1的函数,我是匿名函数
    });
    //命名函数
    function f2(){
        console.log("f2的函数");
    }
    f1(f2);
    //函数作为参数时，如果是命名函数，那么只用传入命名函数的名称，没有括号
</script> -->
<!-- <script>
    function f1(fn){
        setInterval(function(){
            console.log("定时器开启");
            fn();
            console.log("定时器关闭");
        },1000)
    }
    f1(function(){})//定时输出定时器开启，定时器关闭，若无匿名函数，则遇到fn()时报错
</script> -->

<!-- 高阶函数之函数作为返回值使用 -->
<!-- <script>
    function f1(){
        console.log("f1函数开始");
        return function(){
            console.log("我是函数，但是此时是作为返回值使用的");
        }
    }
    var ff=f1();
    ff();
</script> -->
<!-- <script>
    var num=10;
    console.log(typeof num);//获取num这个变量的数据类型
    var obj={};//对象
    //判断这个对象是不是某个数据类型的
    console.log(obj instanceof Object);
    //获取某个对象的数据类型的例子
    Object.prototype.toString.call([]/Date);//此时得到的就是这括号里这个对象的类型的样子
     //此时输出的是Object的数据类型   [object Object]
    console.log(Object.prototype.toString());
    //输出的数组的数据类型      [object Array]
    console.log(Object.prototype.toString.call([]));
    var arr=[10,20,30];
    console.log(Object.prototype.toString.call(arr));
    console.log(Object.prototype.toString.call(new Date()));
</script> -->


<!-- 函数作为参数使用 -->
<!-- <script>
    //sort排序不稳定，解决方法：
    var arr=[100,1,50,26,89,100,108];
    arr.sort(function (x,y){
        if(x>y){
            return 1;//相当于x-y>0
        }else if(x==y){
            return 0;
        }else{
            return -1
        }
    });
    console.log(arr)//按从小到大顺序排列

</script> -->

<!-- 作用域链与预解析 -->
<!-- <script>
    var num = 10;//作用域链 级别：0
    function f1(){
        var num=20;//作用域链 级别：1
        function f2(){
            var num=30;//作用域链 级别：2
            console.log(num);
        }
        f2();
    }
    f1();//30
</script> -->
<!--预解析—— 变量的提升 -->
<!-- <script>
    console.log(num);
    var num=100;
    //输出undefined，上述代码相当于var num ,console,num=100;
</script> -->

<!-- 闭包 -->
<!-- 普通函数 -->
<!-- <script>
    function f1(){
        var num = 10;
        num++;
        return num;
    }
    console.log(f1());
    console.log(f1());
    console.log(f1());//全部输出11
</script> -->
<!-- 函数模式的闭包 -->
<!-- <script>
    function f2(){
        var num = 10;
        return function (){
            num++;
            return num;
        }
    }
    var ff=f2();
    console.log(ff())//11
    console.log(ff())//12
    console.log(ff())//13
    //相当于只调用了一次f2函数中的num=10,在每次调用函数内部之后都会存在数据缓存
</script> -->
<!-- 利用闭包产生3个值相等的随机数
<script>
    function f1(){
        var num=parseInt(Math.random()*10+1);
        return function(){
            return num;
        }
    }
    var ff=f1();
    console.log(ff());
    console.log(ff());
    console.log(ff());
    //总结：要想缓存数据，就把这个数据放到外层的函数和里层的函数之间
</script> -->


<!-- 递归:用于自身调用，减少不必要的代码 
函数中调用函数自己,此时就是递归,递归一定要有结束的条件
-->
<!-- 求N个数字的和，计算1+2+3+4+5 -->
<!-- <script>
    //函数的声明
    function getSum(x){
        if(x==1){
            return 1;
        }
        return x+getSum(x-1);
    }
    //函数的调用
    console.log(getSum(5));
</script> -->
<!-- 求一个数字各个位数上的数字的和 -->
<!-- <script>
    function getSum(x){253
        if(x<10){
            return x;
        }
        return (x%10+getSum(parseInt(x/10)));
    }
    console.log(getSum(128))
</script> -->


<!-- 浅拷贝 -->
<!-- 浅拷贝就是复制，相当于把一个对象的所有内容复制一份给另一个对象 -->
<!-- <script>
    var obj1={
        age:10,
        sex:"男",
        car:["奔驰","宝马","奥迪"]
    };
    var obj2={
        name:"jk"
    };

    function extend(a,b){
        for(var key in a){
            b[key]=a[key];
        }
    }
    extend(obj1,obj2);
    console.log(obj2);
    console.log(obj1);
    
</script> -->

<!-- 深拷贝 -->
<!-- 拷贝还是复制，而他相对于浅拷贝的区别在于他复制数组和对象时，不是直接一块复制，而是一个一个的复制到另一个对象中 -->
</body>

</body>
</html>